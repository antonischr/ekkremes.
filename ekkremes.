#include<Stepper.h> //Εισάγουμε την βιβλιοθήκη του stepper motor                 
Stepper myStepper(2048,8,10,9,11); // Δημιουργία αντικειμένου stepper , και στις παρενθέσεις αναφέρουμε τα pins που το έχουμε συνδέσει 
                                   // ,στην πρώτη τιμή της παρένθεσης θέτουμε σε πόσα steps γίνεται μια πλήρης περιστροφή
int motorSpeed=10; // Θέτουμε την ταχύτητα περιστροφής

#include <LiquidCrystal_I2C.h> // εισάγουμε την βιβλιοθήκη της lcd οθόνης
LiquidCrystal_I2C lcd(0x27,16,2); // Δημιουργία αντικειμένου οθόνης, παρένθεση (I2C ADRESS,στήλες,γραμμές)

bool rigt_button ; // λογική μεταβλητή δεξιού κουμπιού
bool mean_button;  // λογική μεταβλητή μεσαίου κουμπιού 
bool left_button;  // λογική μεταβλητή αριστερού κουμπιού

const int trigPin1 = 6; //Σταθερή ακέραια μεταβλητή trig pin του αισθητήρα απόστασης(trig-> pin 6)
const int echoPin1 = 5; //Σταθερή ακέραια μεταβλητή echo pin του αισθητήρα απόστασης(echo-> pin 5)
float duration , distance; // Μεταβλητές διάρκειας και απόστασης σε δεκαδική μορφή


const int arraySize = 11; // Μεταβλητή που θα μας δώσει τις θέσεις του πίνακα 
int sensorPin = A0; //Ακέραια μεταβλητή της φωτοαντίστασης (συνδέεται στο pin Α0)
int lightThreshold ; // Ακέραια μεταβλητή οριακής τιμής φωτοαντίστασης
float timestamps[arraySize]; //Δημιουργία πίνακα με 11 θέσεις (αποθηκεύει χρονικές στιγμές)
int state =  0 ; // Ακέραια μεταβλητή θα μας βοηθήσει στην σωστή καταμέτρηση περιόδων
int laser = 7;  //Ακέραια μεταβλητή laser (συνδέεται στο pin 7)
float period ;  // Δημιουργία μεταβλητής period σε δεκαδική μοργή 
static int index = 0; // Δημιουργία μεταβλητής η οποία θα αναφέρεται στην θέση του πίνακα
bool computed = 0; // Δημιουργία λογικής μεταβλητής 
float L; // L= μήκος νήματος
float h = 0.655 ; // h = απόσταση από το δάπεδο εως τον άξονα περιστροφής
float radius = 0.0125; // ακτίνα αντικειμένου
float g ; // Μεταβλητή g με την οποία θα υπολογίζουμε την επιτάχυνση της βαρύτητας 
int state2 = 3 ; // βοηθητική μεταβλητή 
//int delayy = 100;
int buzzer = 12; // Μεταβλητή buzzer-> pin12
float c = 0.038; // Σταθερά μετατόπισης κέντρου βάρους εκκρεμούς


void setup() {
  
  myStepper.setSpeed(motorSpeed); // θέτουμε την ταχύτητα του στέπερ

  pinMode(sensorPin,INPUT); // δηλώνουμε το pin της φωτοαντίστασης ως είσοδο
  pinMode(laser,OUTPUT);    // όμοια το laser ως έξοδο
  pinMode(buzzer,OUTPUT);   // το μπάζερ ως έξοδο
  pinMode(2, INPUT);     
  pinMode(3, INPUT);
  pinMode(4, INPUT); // Τα pin 2,3,4 ώς είσοδο , είναι τα pins των κουμπιών 


  lcd.init(); // Θέτουμε σε λειτουργία την  οθόνη
  lcd.backlight(); // ενεργοποιούμαι τον οπίσθιο φωτισμό
  lcd.setCursor(0,0); // Θέτουμε την  πρώτη γραμμή και την πρώτη σειρά ως σημείο έναρξης προβολής χαρακτήρων
  lcd.print("WELCOME"); // εμφανίζεται μήνυμα welcome

  pinMode(trigPin1, OUTPUT); // Θέτουμε το trigpin1 του αισθητήρα απόστασης ως έξοδο (πομπός)
  pinMode(echoPin1, INPUT);  // και το echo ως είσοδο(δέκτης)

  Serial.begin(9600); // Ξεκινάει η σειριακή επικοινωνία με baud rate 9600ms
  digitalWrite(laser,HIGH); // Με την έναρξη του προγράμματος ενεργοποιείται το laser
  
}

void loop() {

///////////////////////////////Αρχή προγραμματισμού κουμπιών/////////////////////////////////

rigt_button = digitalRead(2);
mean_button = digitalRead(3);
left_button = digitalRead(4); // Για κάθε κουμπί γίνεται ψηφιακό διάβασμα των αντίστοιχων pin(2,3,4)

if( rigt_button == true) // Aν το δεξί κουμπί πατηθεί 
{
  myStepper.step(1);     // Κάνε +1 step στον κινητήρα(κινήσου δεξιά)
}
if(left_button == 1) // Αν το αριστερό κουμπί πατηθεί 
{
  myStepper.step(-1);    // Κάνε -1 step στον κινητήρα(αριστερά δηλαδή)
}

if(rigt_button == false && left_button == false) //Αν δεν πατάς κανένα από τα ακριανά κουμπιά 
{
  digitalWrite(8,LOW); 
  digitalWrite(9,LOW);
  digitalWrite(10,LOW);
  digitalWrite(11,LOW);   //Τότε απενεργοποίησέ το στέπερ (αυτό γίνεται για να μην ρίχνει την τάση, αν είναι ενεργοποιημένος ακόμα και 
                          // ας μην κινείται ρίχνει την τάση και επηρεάζει μετρήσεις, φωτεινότητα οθόνης, laser κλπ)

}

if(mean_button == true )  // Αν πατήσεις το μεσαίο κουμπί  
{ 
  state2 = 0;  //Αρχικά κάνε μου το state2=0
  lightThreshold = analogRead(sensorPin); // Κάνε οριακή τιμή φωτοαντίστασης της τιμή που διαβάζεις μόλις πατάω το κουμπί 
  lcd.clear(); // καθάρισε την οθόνη
  
  getDist(); //Πάρε την απόσταση που μετράει ο αισθητήρας
  L = h- distance- radius - c  ;  // Υπολόγισε το L βάση αυτού του τύπου
  lcd.setCursor(0, 0);  // Ξανά θέσε σημείο αναφορά γραφής στην οθόνη το 0,0
  lcd.print("L=");
  lcd.print(L,3);
  lcd.print(" m");
  delay(300);      //Εμφάνισε μου το L που διαβάζεις σε m , παίρνει τιμές κάθε 300ms όση ώρα πατάς το κουμπί
 
  
  computed = 0;  // κάνε μου το computed = 0
  index = 0;     //Πήγαινε στην πρώτη θέση του πίνακα (οι μεταβλητές αυτές προσφέρουν επαναληψημότητα στο πρόγραμμα)

}
if(mean_button==false&& state2==0 && computed == 0) //Όταν αφήσεις το μεσαίο κουμπί 
{
  state2=1;  //κάνε το state2 =1 
  delay(1000);  // περίμενε 1 δευτερόλεπτο , τέντωσε το εκκρεμές
  lcd.clear();
  lcd.print("OK!"); //εμφάνισε μήνυμα ΟΚ, και τότε μπορείςς να αφήσεις το εκκρεμές να κινηθεί
}

/////////////////////////////////Τέλος προγραματισμού κουμπιών//////////////////////////////////

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Αρχή μέτρησης χρονικών στιμγών Τ1,2,3...\\\\\\\\\\\\\\\\\\\\\\\


 if(index < arraySize && state2==1)  //Αν οι τιμές του πίνακα δεν έχουν φουλάρει και έχεις μετρήσει πρώτα το L (δλδ state2=1)
{

  int lightValue = analogRead(sensorPin); // Ανάγνωση της τιμής της φωτοαντίστασης


  if (lightValue < (lightThreshold-100) && state == 0) // Έλεγχος για την πτώση της φωτεινότητας κάτω από το όριο με ασφάλεια 100 μονάδων
    {
    timestamps[index] = float(millis())/1000;  // Τότε αποθήκευση στην πρώτη τιμή του πίνακα την χρονική στιγμή από την  εντολή millis 
    index = (index + 1); // πήγαινε στην επόμενη θέση του πίνακα 
    tone(buzzer,3000,40); // κάνε έναν μικρό ήχο για 40ms
    lcd.clear();  // καθάρισε την οθόνη

 
   lightValue = analogRead(sensorPin); //Διάβασε την τιμή της φωτοαντίστασης

   if(lightValue == lightThreshold) //Αφού  περάσει το νήμα από μπροστά, άρα η τιμή της φωτοαντίστασης έχει την οριακή τιμή του 
                                    //threshhold
   {
     state = 1; //Κάνε το state = 1 έτσι ώστε όταν ξανά περάσει από μπροστά(στην κάθοδο) να μήν πάρει πάλι μέτρηση
   }
   
  }
  
   if(state == 1) 
   {
     lightValue = analogRead(sensorPin);

      if(lightValue < (lightThreshold) )
    { 
      state = 0 ;
    }

   }  
   //Από σειρά 145-154 : Στην ουσία του λέμε να διαβάσει την τιμή της φωτοαντίστασης και όταν ξανά περάσει από μπροστά κατά την κάθοδο 
   // δηλαδή το lightValue γίνει μικρότερο της οριακής τιμής, πρώτων να μην πάρει μέτρηση, αλλά να κάνει και το state=0 έτσι ώστε όταν 
   // ξανά περάσει από μπροστά κατά την άνοδο να πάρει τότε μέτρηση  
}

//////////////ΤΕΛΟΣ ΚΑΤΑΜΕΤΡΗΣΗΣ ΧΡΟΝΙΚΩΝ ΣΤΙΓΜΩΝ///////////////////////////
\\\\\\\\\\\\\\ΑΡΧΗ ΥΠΟΛΟΓΙΣΜΟΥ ΠΕΡΙΟΔΩΝ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

else if (index == arraySize && computed == 0) // Αλλιώς εάν έχουν συμπληρωθεί όλες οι τιμές του πίνακα 
{
computed = 1; // κάνε το computed=1 για να μην πάρει και άλλες τιμές οι οποίες θα αντικαταστήσουν τις παλιές τιμές που πήραμε
float periods[arraySize-1]; //Δημιουργία πίνακα περιόδων (11 χρονικές στιγμές = 10 περίοδοι)
float sum=0; // δημιουργία δεκαδικής μεταβλητής αθροίσματος

for (int i=0; i<arraySize-1; i++) 
{
periods[i] = timestamps[i+1] - timestamps[i]; //δημιουργία πίνακα περιόδων ως την διαφορά των (Τ2-Τ1...κλπ)
sum = sum + periods[i]; //Άθροισμα περιόδων
}

float meanPeriod = sum / (arraySize-1); // Μέσος όρος περιόδων

//////////////////////////////ΤΕΛΟΣ ΥΠΟΛΟΓΙΣΜΟΥ ΠΕΡΙΟΔΩΝ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ΑΡΧΗ ΔΙΟΡΘΩΣΗΣ ΤΙΜΩΝ///////////////////////////////////

float new_sum=0; 
float count_elems=0;

for (int i=0; i<arraySize-1;i++){
if (abs(periods[i]-meanPeriod)<0.05*meanPeriod) //Αν κάποια τιμή της περιόδου είναι διαφορετική από το +-5% της μέσης τιμής περιόδων 
{
new_sum += periods[i];     //τότε κάνε μου νέο άθροισμα
count_elems++;             // και νέα καταγραφή στοιχείων του πίνακα 
}
}

float newMeanPeriod = new_sum / count_elems;

//////////////////////////////ΤΕΛΟΣ ΔΙΟΡΘΩΣΗΣ ΤΙΜΩΝ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

g = (L*4*3.14*3.14)/(meanPeriod*meanPeriod) ; //Υπολογισμός του g
lcd.setCursor(0,0);
Serial.print("g=");
Serial.println(g);
lcd.backlight();
lcd.print("g= ");
lcd.print(g,3);
lcd.print(" m/s^2");
lcd.setCursor(0,1);
lcd.print("Period= ");
lcd.print(meanPeriod);
lcd.print("sec");
}
  
}


float getDist()     // Κώδικας για την σωστή λειτουρργία του αισθητήρα απόστασης και μέτρηση σε m
{

  digitalWrite(trigPin1, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin1, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin1, LOW);
  duration = pulseIn(echoPin1, HIGH);
  distance = duration * 0.034 / 200 ;
  
  return distance ;
}
